
我们能够灵活地使用高阶组件（加分项 🥰），可以让项目代码变得更加优雅，同时增强代码的复用性和灵活性，提升开发效率。
同时，了解高阶组件对我们理解各种 React.js 第三方库的原理很有帮助 

抽取重复代码，实现组件复用，常见场景：页面复用。
条件渲染，控制组件的渲染逻辑（渲染劫持），常见场景：权限控制。
捕获/劫持被处理组件的生命周期，常见场景：组件渲染性能追踪、日志打点。

通常情况下，实现高阶组件的方式有以下两种:
属性代理(Props Proxy)
返回一个无状态（stateless）的函数组件
返回一个 class 组件
反向继承(Inheritance Inversion)

高阶组件实现方式的差异性决定了它们各自的应用场景：一个 React 组件包含了 props、state、ref、生命周期方法、static方法和React 元素树几个重要部分，所以我将从以下几个方面对比两种高阶组件实现方式的差异性：

原组件能否被包裹
原组件是否被继承
能否读取/操作原组件的 props
能否读取/操作原组件的 state
能否通过 ref 访问到原组件的 dom 元素
是否影响原组件某些生命周期等方法
是否取到原组件 static 方法
能否劫持原组件生命周期方法
能否渲染劫持

属性代理
属性代理是最常见的实现方式，它本质上是使用组合的方式，通过将组件包装在容器组件中实现功能。
属性代理方式实现的高阶组件和原组件的生命周期关系完全是React父子组件的生命周期关系，所以该方式实现的高阶组件会影响原组件某些生命周期等方法。

属性代理  操作 props  抽象 state

ref 属性只能声明在 class 类型的组件上，而无法声明在函数类型的组件上（因为无状态组件没有实例）。
通过属性代理方式实现的高阶组件无法直接获取原组件的 refs 引用，但是可以通过在原组件的ref回调函数中调用父组件传入的 ref 回调函数来获取原组件的refs 引用。
假设有一个 User 组件（原组件）
用其他元素包裹传入的组件


反向继承

高阶组件（HOC）是 React 中用于复用组件逻辑的一种高级技巧。HOC 自身不是 React API 的一部分，它是一种基于 React 的组合特性而形成的设计模式。

全方位看高阶组件   1 几种包装强化组件的方式

① mixin模式  ②extends继承模式  ③HOC模式  ④自定义hooks模式

2 高阶组件产生初衷
① 复用逻辑 ② 强化props ③ 赋能组件 ④ 控制渲染
① 复用逻辑：高阶组件更像是一个加工react组件的工厂，批量对原有组件进行加工，包装处理。我们可以根据业务需求定制化专属的HOC,这样可以解决复用逻辑。
② 强化props：这个是HOC最常用的用法之一，高阶组件返回的组件，可以劫持上一层传过来的props,然后混入新的props,来增强组件的功能。代表作react-router中的withRouter。
③ 赋能组件：HOC有一项独特的特性，就是可以给被HOC包裹的业务组件，提供一些拓展功能，比如说额外的生命周期，额外的事件，但是这种HOC，可能需要和业务组件紧密结合。典型案例react-keepalive-router中的 keepaliveLifeCycle就是通过HOC方式，给业务组件增加了额外的生命周期。
④ 控制渲染：劫持渲染是hoc一个特性，在wrapComponent包装组件中，可以对原来的组件，进行条件渲染，节流渲染，懒加载等功能，后面会详细讲解，典型代表做react-redux中connect和 dva中 dynamic 组件懒加载。

使用：装饰器模式(越靠近Index组件的，就是越内层的HOC,离组件Index也就越近)和函数包裹模式

这样每个静态方法都绑定会很累，尤其对于开源的hoc，对原生组件的静态方法是未知的,我们可以使用 hoist-non-react-statics 自动拷贝所有的静态方法:

3 跨层级捕获ref
高阶组件的约定是将所有 props 传递给被包装组件，但这对于 refs 并不适用。那是因为 ref 实际上并不是一个 prop - 就像 key 一样，它是由 React 专门处理的。如果将 ref 添加到 HOC 的返回组件中，则 ref 引用指向容器组件，而不是被包装组件。我们可以通过forwardRef来解决这个问题。